 # Кратко - что такое DDD и его главные строительны блоки

 Область применения DDD - это любой проект, написанный на языке программирования высокого уровня. 
 У любой задачи есть предметная область. Основная идея DDD заключается в использовании терминологии предметной области в исходном коде программы. Терминология предметной области, или Единый язык (ubiquitous language) включает в себя сущности и операции над ними, связи между сущностями, события и реакции на них. Основная цель DDD состоит в максимально приближенном выражении процессов, происходящих в системе с сипользованием Единого языка. 

 В книге [DDD] суммируется набор инструментов, с помощью которых реализуется DDD. 

Вот, возможно, самые важные из них:

 * Ограниченный контекст (Bounded Context), внутри которого можно построить непротиворечивую модель. Все типы объектов, кроме событий, существуют и действуют внутри данного ограниченного контекста.
 * Сущности (Entities) это объекты с изменяемым состоянием. То есть объекты-сущности могут изменяться частично.
 * Объекты-значения (ValueObject's) это объекты, которые изменяются только целиком. 
 * Репозитории - служат для хранения сущностей. На самом деле, следует использовать репозитории только для хранения агрегатов.
 * Сервисы - служат для подготовки и выполнения операций над агрегатами
 * Агрегаты - одна или несколько сущностей, которые должны сохранятся в одной транзакции. Корнем агрегат является сущность, которая выдна другим агрегатам. Внутренности агрегата скрыты от внешнего мира. 
 * События - это простые объекты, которые генерируются моделью в случае, когда нужно сообщить об изменении состояния данного ограниченного контекста. 

* Отображение контекста (Context Mapping) Ограниченные контексты в рамках одной системы должны взаимодействовать. Чтобы избежать т.н. утечки контекста, т.е. использования напрямую объектов модели одного контекста в другом контексте, используются механизмы преобразования сходных концепций одной модели в понятия другой модели. Одним из часто используемых паттернов  сдесь является антикоррозийный слой ("Anti-Corruption-Layer")


Эти и некоторые другие более специализированные инструменты помогают реализовать бизнес-процессы наиболее выразительным образом. 
Одним из важнейших этапов проектирования мимтемы с использованием DDD является моделирование агрегатов. При этом нужно придерживаться нескольких основных  правил:

* Стараться, чтобы агрегат был небольшим. Идеально, если агрегат - это одна сущность. При этом сущность может сключать в себя несколько объектов-значений. 
* Учитывать, что в одной транзакции сохраняется один экземпляр агрегата. 

Подробнее об этом смотри [DDD_IMPL]. 

Рассмотрим как будет выглядеть процесс поиска агрегатов в предметной области на примере проектирования интернет-магазина электронных товаров. При оплате заказа в интернтет-магазине пользователю становятся доступны для скачаивания товары, которые были в заказе.

Мы могли бы в таком случае ввести агрегат User, у которого есть список  заказов. Каждый заказ, в свою очередь, имеет один или несколько позиций.  В этом случае мы можем ввести операцию "buy" у корня агрегата User:

[code lang="java"]

@Transactional
public void buyCatalogItems(UserId userId, List<CatalogItemId> catalogItemIds) {
	
	Assert.notNull(userId);
	Assert.notEmpty(catalogItemIds);

	User user = usersRepository.findOne(userId);
	List<CatalogItem> items = catalogRepository.findByIds(catalogItemIds);

	user.buy(items);

}

[/code]

Приведенный выше код метода из некоторого сервиса выполняется в рамках одной транзакции. В методе используются два репозитория для получения объекта User и списка единиц каталога. В методе, как и положено, изменяется один агрегат - User. Скорее всего, внутри метода buy происходит создание заказа, добавление к заказу единиц. При этом автоматически купленные товары будут доступны данному пользователю, т.к. они живут внутри агрегата User.

Это будет работать до тех пор, пока мы не захотим полуится полную статистику по всем заказам в системе. В этом случае становится понятно, что модель с агрегатов User, включающим в себя заказа, не адекватна предметной области. 

Очевидно, что необходимо выделить отдельный агрегат Order:

<img src="../images/02.01.orderaggregateroot.png">

Заказ по прежнему содержит список единиц. Связть между заказом и пользователем выражена спомощью специального объекта-значения UserId. 
Такие инструменты как Hibernate позволяют легко моделировать связи между сущностями с помошью отношения типа OneToMany или ManyToMany. 
Поэтому, может показаться, что проще реализовать связть между заказом и пользователем с помощью такой конструкции:

[code lang="java"]

@Entity
public class Order {
	
	....

	@ManyToOne
	User user;

	....	
}

[/code]

Однако, таких тесных связей между агрегатами следует избегать. Причина заключается в эффективности запросов и границах транзакций. 

Допустим, мы хотим получить выборку заказов данного пользователя, включая только заказы с суммой более 100 руб. 
Тогда мы выполним такой JPQL-запрос (если используется JPA):

[code lang="sql"]
select Order o where o.user.id=:userId and o.total > 100
[/code]

Такой запрос будет включать в себя выборку по двум таблицам - orders и users. Поэтому, транзакция  блокировки не только строку в таблице orders, но и строку в users. В высоконагруженных системах это может привести к конфликтам между транзакциями чтения и записи. 