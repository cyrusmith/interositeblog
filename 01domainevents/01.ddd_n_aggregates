 # Кратко - что такое DDD и его главные строительны блоки

 Область применения DDD - это любой проект, написанный на языке программирования высокого уровня. 
 У любой задачи есть предметная область. Основная идея DDD заключается в использовании терминологии предметной области в исходном коде программы. Терминология предметной области, или Единый язык (ubiquitous language) включает в себя сущности и операции над ними, связи между сущностями, события и реакции на них. Основная цель DDD состоит в максимально приближенном выражении процессов, происходящих в системе с сипользованием Единого языка. 

 В книге [DDD] суммируется набор инструментов, с помощью которых реализуется DDD. 

Вот, возможно, самые важные из них:

 * Ограниченный контекст (Bounded Context), внутри которого можно построить непротиворечивую модель. Все типы объектов, кроме событий, существуют и действуют внутри данного ограниченного контекста.
 * Сущности (Entities) это объекты с изменяемым состоянием. То есть объекты-сущности могут изменяться частично.
 * Объекты-значения (ValueObject's) это объекты, которые изменяются только целиком. 
 * Репозитории - служат для хранения сущностей. На самом деле, следует использовать репозитории только для хранения агрегатов.
 * Сервисы - служат для подготовки и выполнения операций над агрегатами
 * Агрегаты - одна или несколько сущностей, которые должны сохранятся в одной транзакции. Корнем агрегат является сущность, которая выдна другим агрегатам. Внутренности агрегата скрыты от внешнего мира. 
 * События - это простые объекты, которые генерируются моделью в случае, когда нужно сообщить об изменении состояния данного ограниченного контекста. 

* Отображение контекста (Context Mapping) Ограниченные контексты в рамках одной системы должны взаимодействовать. Чтобы избежать т.н. утечки контекста, т.е. использования напрямую объектов модели одного контекста в другом контексте, используются механизмы преобразования сходных концепций одной модели в понятия другой модели. Одним из часто используемых паттернов  сдесь является антикоррозийный слой ("Anti-Corruption-Layer")


Эти и некоторые другие более специализированные инструменты помогают реализовать бизнес-процессы наиболее выразительным образом. 
Одним из важнейших этапов проектирования мимтемы с использованием DDD является моделирование агрегатов. При этом нужно придерживаться нескольких основных  правил:

* Стараться, чтобы агрегат был небольшим. Идеально, если агрегат - это одна сущность. При этом сущность может сключать в себя несколько объектов-значений. 
* Учитывать, что в одной транзакции сохраняется один экземпляр агрегата. 

Подробнее об этом смотри [DDD_IMPL]. 

Рассмотрим как будет выглядеть процесс поиска агрегатов в предметной области на примере проектирования интернет-магазина электронных товаров. При оплате заказа в интернтет-магазине пользователю становятся доступны для скачаивания товары, которые были в заказе.

Мы могли бы в таком случае ввести агрегат User, у которого есть список  заказов. Каждый заказ, в свою очередь, имеет один или несколько позиций.  В этом случае мы можем ввести операцию "buy" у корня агрегата User:

[code lang="java"]

@Transactional
public void buyCatalogItems(UserId userId, List<CatalogItemId> catalogItemIds) {
	
	Assert.notNull(userId);
	Assert.notEmpty(catalogItemIds);

	User user = usersRepository.findOne(userId);
	List<CatalogItem> items = catalogRepository.findByIds(catalogItemIds);

	user.buy(items);

}

[/code]

Приведенный выше код метода из некоторого сервиса выполняется в рамках одной транзакции. В методе используются два репозитория для получения объекта User и списка единиц каталога. В методе, как и положено, изменяется один агрегат - User. Скорее всего, внутри метода buy происходит создание заказа, добавление к заказу единиц. При этом автоматически купленные товары будут доступны данному пользователю, т.к. они живут внутри агрегата User.

Это будет работать до тех пор, пока мы не захотим полуится полную статистику по всем заказам в системе. В этом случае становится понятно, что модель с агрегатов User, включающим в себя заказа, не адекватна предметной области. При выборке заказов за определенный период нам пришлось бы обращаться к заказам через объект пользователя. Конечно, всегда можно напрямую обратиться к БД используюя jdbc, но это конечно, уже никакого отношения не имеет к разработке в стиле DDD.

Очевидно, что необходимо выделить отдельный агрегат Order:

<img src="../images/02.01.orderaggregateroot.png">

Заказ по прежнему содержит список единиц. Связть между заказом и пользователем выражена спомощью специального объекта-значения UserId. 
Можно моделировать связи между агрегатами включая ссылку на другой объект:

[code lang="java"]

@Entity
public class Order {
	
	....

	@ManyToOne
	User user;

	....	
}

[/code]

Иногда это действительно удобно и проше всего связать сущности с помощью @OneToOne @OneToMany. При все м при этом наибольшую гибкость при моделировании обеспечивает именно связть с помошью объектов-идентификаторов. Поэтому последние использовать всегда предпочтительнее.

Операция покупки теперь может выглядеть так:

[code lang="java"]

@Transactional
public void buyCatalogItems(UserId userId, List<CatalogItemId> catalogItemIds) {	
	List<CatalogItem> items = catalogRepository.findByIds(catalogItemIds);
	Order order = Order.createWithItems(userId, items);
	order.complete();
}
	
[/code]

Заказ сохранен, но нам нужно добавить товары в личный кабинет пользователя. Согласно одному из основных правил для агрегатов,
в обной транзакции нужно сохрянь один экземпляр агрегата. Поскольку User и Order теперь разные агрегаты мы не можем сразу после order.complete() вызвать user.addItems(items).

В данном конкретном примере нам и не обязательно сохранять заказ и добавлять товары пользователю в одной транзакции. Если мы будем уверены, что товары будут в итоге добавлены, хотя бы и немного позже создания заказа, то это также не будет противоречить сценарию использования. Пользователь совершил покупку и теперь главное обечпечить, чтобы пока он идет в личный кабинет, товары уже были добавлены к его аккаунту. 

Это и есть т.н. отложенная консистентность. Мы хотим, чтобы некий инвариант был выполнен, но необзятельно в течение одной атомарной операции. Вместо этого, можно с вомошью отложенног вызова обеспечить выполнение всего инварианта в некоторый последующий момент времени.

Применение отложенной консистентности хорошо согласуется с взаимодействием между агрегатами посредством событий предметной области. 
Про создании заказа система получает сообщениео том, что новый заказ был создан. Система отвечает на событие, в часности, она может добавить товары из нового заказа в личный кабинет пользователя.

Процесс взаимодействия будет выглядеть таким образом. Сначала создаем событие и публикуем его:

[code lang="java"]

@Autowired
private EventPublisher eventPublisher;

@Transactional
public void buyCatalogItems(UserId userId, List<CatalogItemId> catalogItemIds) {	
	List<CatalogItem> items = catalogRepository.findByIds(catalogItemIds);
	Order order = Order.createWithItems(userId, items);
	order.complete();
	eventPublisher.publish(new OrderCreatedEvent(
		order.getId()
	));
}
	
[/code]

Затем, в обработчике события мы добавляем товары в ЛК:

[code lang="java"]

@Transactional
@EventHandler(eventType=OrderCreatedEvent.class)
public void addItemsToUser(OrderCreatedEvent event) {	
	Order order = orderRepository.findOne(event.getOrderId());
	List<CatalogItem> items = order.getItems();
	if(!order.isComplete()) {
		return;
	}
	UserId userId = order.getUserId();
	User user = usersRepository.findOne(userId);

	for(CatalogItem item : items) {
		if(!user.hasItem(item)) {
			user.addItem(item);
		}
	}

}
	
[/code]

Таким образом, операции над разными агрегатами выполняются в разных методах и в разных транзакциях. Это обеспечивает максивальную гибкость в аржитектуре и возможность масштабирования системы без бополнительного рефакторинга.

Остается открытм вопрос - как гарантировать отправку и обработку сообщений в системе? Далее мы расмотрим пример реализации событий в предметной области с использованием amqp и возможностей Spring Integration. 